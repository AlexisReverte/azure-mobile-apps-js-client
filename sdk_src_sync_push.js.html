<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>sdk/src/sync/push.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MobileServiceClient.html">MobileServiceClient</a><ul class='methods'><li data-type='method'><a href="MobileServiceClient.html#getSyncContext">getSyncContext</a></li><li data-type='method'><a href="MobileServiceClient.html#getSyncTable">getSyncTable</a></li><li data-type='method'><a href="MobileServiceClient.html#getTable">getTable</a></li><li data-type='method'><a href="MobileServiceClient.html#invokeApi">invokeApi</a></li><li data-type='method'><a href="MobileServiceClient.html#login">login</a></li><li data-type='method'><a href="MobileServiceClient.html#loginWithOptions">loginWithOptions</a></li><li data-type='method'><a href="MobileServiceClient.html#logout">logout</a></li><li data-type='method'><a href="MobileServiceClient.html#withFilter">withFilter</a></li></ul></li><li><a href="MobileServiceSqliteStore.html">MobileServiceSqliteStore</a><ul class='methods'><li data-type='method'><a href="MobileServiceSqliteStore.html#defineTable">defineTable</a></li><li data-type='method'><a href="MobileServiceSqliteStore.html#del">del</a></li><li data-type='method'><a href="MobileServiceSqliteStore.html#lookup">lookup</a></li><li data-type='method'><a href="MobileServiceSqliteStore.html#read">read</a></li><li data-type='method'><a href="MobileServiceSqliteStore.html#upsert">upsert</a></li></ul></li><li><a href="MobileServiceSyncContext.html">MobileServiceSyncContext</a><ul class='methods'><li data-type='method'><a href="MobileServiceSyncContext.html#del">del</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#initialize">initialize</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#insert">insert</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#lookup">lookup</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#pull">pull</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#purge">purge</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#push">push</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#read">read</a></li><li data-type='method'><a href="MobileServiceSyncContext.html#update">update</a></li></ul></li><li><a href="MobileServiceSyncTable.html">MobileServiceSyncTable</a><ul class='methods'><li data-type='method'><a href="MobileServiceSyncTable.html#del">del</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#getMobileServiceClient">getMobileServiceClient</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#getTableName">getTableName</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#insert">insert</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#lookup">lookup</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#pull">pull</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#purge">purge</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#read">read</a></li><li data-type='method'><a href="MobileServiceSyncTable.html#update">update</a></li></ul></li><li><a href="MobileServiceTable.html">MobileServiceTable</a><ul class='methods'><li data-type='method'><a href="MobileServiceTable.html#del">del</a></li><li data-type='method'><a href="MobileServiceTable.html#getMobileServiceClient">getMobileServiceClient</a></li><li data-type='method'><a href="MobileServiceTable.html#getTableName">getTableName</a></li><li data-type='method'><a href="MobileServiceTable.html#insert">insert</a></li><li data-type='method'><a href="MobileServiceTable.html#lookup">lookup</a></li><li data-type='method'><a href="MobileServiceTable.html#read">read</a></li><li data-type='method'><a href="MobileServiceTable.html#update">update</a></li></ul></li><li><a href="Push.html">Push</a><ul class='methods'><li data-type='method'><a href="Push.html#register">register</a></li><li data-type='method'><a href="Push.html#unregister">unregister</a></li></ul></li><li><a href="PushError.html">PushError</a><ul class='methods'><li data-type='method'><a href="PushError.html#cancel">cancel</a></li><li data-type='method'><a href="PushError.html#cancelAndDiscard">cancelAndDiscard</a></li><li data-type='method'><a href="PushError.html#cancelAndUpdate">cancelAndUpdate</a></li><li data-type='method'><a href="PushError.html#changeAction">changeAction</a></li><li data-type='method'><a href="PushError.html#getAction">getAction</a></li><li data-type='method'><a href="PushError.html#getClientRecord">getClientRecord</a></li><li data-type='method'><a href="PushError.html#getError">getError</a></li><li data-type='method'><a href="PushError.html#getServerRecord">getServerRecord</a></li><li data-type='method'><a href="PushError.html#getTableName">getTableName</a></li><li data-type='method'><a href="PushError.html#isConflict">isConflict</a></li><li data-type='method'><a href="PushError.html#update">update</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-azure-mobile-apps-client.html">azure-mobile-apps-client</a></li></ul><h3>Interfaces</h3><ul><li><a href="MobileServiceStore.html">MobileServiceStore</a><ul class='methods'><li data-type='method'><a href="MobileServiceStore.html#defineTable">defineTable</a></li><li data-type='method'><a href="MobileServiceStore.html#del">del</a></li><li data-type='method'><a href="MobileServiceStore.html#lookup">lookup</a></li><li data-type='method'><a href="MobileServiceStore.html#read">read</a></li><li data-type='method'><a href="MobileServiceStore.html#upsert">upsert</a></li></ul></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    
    <h1 class="page-title">sdk/src/sync/push.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>// ----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// ----------------------------------------------------------------------------

/**
 * @file Table push logic implementation
 * @private
 */

var Validate = require('../Utilities/Validate'),
    Query = require('azure-query-js').Query,
    verror = require('verror'),
    Platform = require('../Platform'),
    taskRunner = require('../Utilities/taskRunner'),
    MobileServiceTable = require('../MobileServiceTable'),
    constants = require('../constants'),
    tableConstants = constants.table,
    sysProps = require('../constants').table.sysProps,
    createPushError = require('./pushError').createPushError,
    handlePushError = require('./pushError').handlePushError,
    _ = require('../Utilities/Extensions');

function createPushManager(client, store, storeTaskRunner, operationTableManager) {
    // Task runner for running push tasks. We want only one push to run at a time. 
    var pushTaskRunner = taskRunner(),
        lastProcessedOperationId,
        pushConflicts,
        lastFailedOperationId,
        retryCount,
        maxRetryCount = 5,
        pushHandler;
    
    return {
        push: push
    };

    /**
     * Pushes operations performed on the local store to the server tables.
     * 
     * @returns A promise that is fulfilled when all pending operations are pushed. Conflict errors won't fail the push operation.
     *          All conflicts are collected and returned to the user at the completion of the push operation. 
     *          The promise is rejected if pushing any record fails for reasons other than conflict or is cancelled.
     */
    function push(handler) {
        return pushTaskRunner.run(function() {
            reset();
            pushHandler = handler;
            return pushAllOperations().then(function() {
                return pushConflicts;
            });
        });
    }
    
    // Resets the state for starting a new push operation
    function reset() {
        lastProcessedOperationId = -1; // Initialize to an invalid operation id
        lastFailedOperationId = -1; // Initialize to an invalid operation id
        retryCount = 0;
        pushConflicts = [];
    }
    
    // Pushes all pending operations, one at a time.
    // 1. Read the oldest pending operation
    // 2. If 1 did not fetch any operation, go to 6.
    // 3. Lock the operation obtained in step 1 and push it.
    // 4. If 3 is successful, unlock and remove the locked operation from the operation table and go to 1
    //    Else if 3 fails, unlock the operation.
    // 5. If the error is a conflict, handle the conflict and go to 1.
    // 6. Else, EXIT.
    function pushAllOperations() {
        var currentOperation,
            pushError;
        return readAndLockFirstPendingOperation().then(function(pendingOperation) {
            if (!pendingOperation) {
                return; // No more pending operations. Push is complete
            }
            
            var currentOperation = pendingOperation;
            
            return pushOperation(currentOperation).then(function() {
                return removeLockedOperation();
            }, function(error) {
                // failed to push
                return unlockPendingOperation().then(function() {
                    pushError = createPushError(store, operationTableManager, storeTaskRunner, currentOperation, error);
                    //TODO: If the conflict isn't resolved but the error is marked as handled by the user,
                    //we can end up in an infinite loop. Guard against this by capping the max number of 
                    //times handlePushError can be called for the same record.

                    // We want to reset the retryCount when we move on to the next record
                    if (lastFailedOperationId !== currentOperation.logRecord.id) {
                        lastFailedOperationId = currentOperation.logRecord.id;
                        retryCount = 0;
                    }

                    // Cap the number of times error handling logic is invoked for the same record
                    if (retryCount &lt; maxRetryCount) {
                        ++retryCount;
                        return handlePushError(pushError, pushHandler);
                    }
                });
            }).then(function() {
                if (!pushError) { // no push error
                    lastProcessedOperationId = currentOperation.logRecord.id;
                } else if (pushError &amp;&amp; !pushError.isHandled) { // push failed and not handled

                    // For conflict errors, we add the error to the list of errors and continue pushing other records
                    // For other errors, we abort push.
                    if (pushError.isConflict()) {
                        lastProcessedOperationId = currentOperation.logRecord.id;
                        pushConflicts.push(pushError);
                    } else { 
                        throw new verror.VError(pushError.getError(), 'Push failed while pushing operation for tableName : ' + currentOperation.logRecord.tableName +
                                                                 ', action: ' + currentOperation.logRecord.action +
                                                                 ', and record ID: ' + currentOperation.logRecord.itemId);
                    }
                } else { // push error handled
                    // No action needed - We want the operation to be re-pushed.
                    // No special handling is needed even if the operation was cancelled by the user as part of error handling  
                }
            }).then(function() {
                return pushAllOperations(); // push remaining operations
            });
        });
    }
    
    function readAndLockFirstPendingOperation() {
        return storeTaskRunner.run(function() {
            var pendingOperation;
            return operationTableManager.readFirstPendingOperationWithData(lastProcessedOperationId).then(function(operation) {
                pendingOperation = operation;
                
                if (!pendingOperation) {
                    return;
                }
                
                return operationTableManager.lockOperation(pendingOperation.logRecord.id);
            }).then(function() {
                return pendingOperation;
            });
        });
    }
    
    function unlockPendingOperation() {
        return storeTaskRunner.run(function() {
            return operationTableManager.unlockOperation();
        });
    }
    
    function removeLockedOperation() {
        return storeTaskRunner.run(function() {
            return operationTableManager.removeLockedOperation();
        });
    }
    
    function pushOperation(operation) {
        
        return Platform.async(function(callback) {
            callback();
        })().then(function() {
            // TODO: Invoke push request filter to allow user to change how the record is sent to the server
        }).then(function() {
            // perform push

            var mobileServiceTable = client.getTable(operation.logRecord.tableName);
            mobileServiceTable._features = [constants.features.OfflineSync];
            switch(operation.logRecord.action) {
                case 'insert':
                    removeSysProps(operation.data); // We need to remove system properties before we insert in the server table
                    return mobileServiceTable.insert(operation.data).then(function(result) {
                        return store.upsert(operation.logRecord.tableName, result); // Upsert the result of insert into the local table
                    });
                case 'update':
                    return mobileServiceTable.update(operation.data).then(function(result) {
                        return store.upsert(operation.logRecord.tableName, result); // Upsert the result of update into the local table
                    });
                case 'delete':
                    // Use the version info form the log record.
                    operation.logRecord.metadata = operation.logRecord.metadata || {};
                    return mobileServiceTable.del({id: operation.logRecord.itemId, version: operation.logRecord.metadata.version});
                default:
                    throw new Error('Unsupported action ' + operation.logRecord.action);
            }
            
        }).then(function() {
            // TODO: Invoke hook to notify record push completed successfully
        });
        
    }
    
    function removeSysProps(record) {
        for (var i in sysProps) {
            delete record[sysProps[i]];
        }
    }
}

exports.createPushManager = createPushManager;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Nov 29 2016 23:48:10 GMT-0800 (Pacific Standard Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
